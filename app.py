import streamlit as st
from streamlit_lottie import st_lottie
import json
import pandas as pd
import numpy as np
import altair as alt
import joblib
import base64
from textblob import TextBlob
from fpdf import FPDF
import datetime
import os
import tempfile
import gspread
from oauth2client.service_account import ServiceAccountCredentials
from matplotlib import pyplot as plt
import speech_recognition as sr
import time
import plotly.express as px


# -------------------
# Load logo
with open("tonosense-removebg-preview.png", "rb") as image_file:
    logo_base64 = base64.b64encode(image_file.read()).decode()

st.set_page_config(
    page_title="TonoSense | Emotion & Sentiment Analyzer",
    page_icon="üß†",
    layout="centered",
    initial_sidebar_state="collapsed"
)

def reshape_column(x):
    return x.values.reshape(-1, 1)

pipe_lr = joblib.load(open("text_emotion.pkl", "rb"))
sentiment_pipe = joblib.load(open("reviews_sentiment_with_textblob.pkl", "rb"))

emotions_emoji_dict = {
    "anger": "üò†",
    "fear": "üò®",
    "joy": "üòÇ",
    "love": "‚ù§Ô∏è",
    "sadness": "üòî",
    "surprise": "üòÆ"
}

sentiment_emoji_dict = {
    "positive": "üòä",
    "negative": "üòû",
    "neutral": "üòê"
}

def predict_emotions(docx):
    return pipe_lr.predict([docx])[0]

def get_prediction_proba(docx):
    return pipe_lr.predict_proba([docx])

def predict_sentiment(text):
    polarity = TextBlob(text).sentiment.polarity
    subjectivity = TextBlob(text).sentiment.subjectivity
    input_df = pd.DataFrame([{'Text': text, 'Polarity': polarity, 'Subjectivity': subjectivity}])
    return sentiment_pipe.predict(input_df)[0]

def get_sentiment_proba(text):
    polarity = TextBlob(text).sentiment.polarity
    subjectivity = TextBlob(text).sentiment.subjectivity
    input_df = pd.DataFrame([{'Text': text, 'Polarity': polarity, 'Subjectivity': subjectivity}])
    return sentiment_pipe.predict_proba(input_df)

from fpdf import FPDF
import tempfile
import os
import datetime
import matplotlib.pyplot as plt


def export_to_pdf(user_name, user_text, prediction, confidence, analysis_type, proba_df):
    from fpdf import FPDF
    import datetime
    import tempfile
    import os
    import matplotlib.pyplot as plt

    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()

    # --- Black background header ---
    pdf.set_fill_color(0, 74, 173)  # Deep blue
    pdf.rect(0, 0, 210, 40, 'F')

    pdf.set_text_color(255, 255, 255)
    pdf.set_font("Times", 'B', 20)
    pdf.cell(0, 10, "TonoSense Report", ln=True, align='C')
    pdf.ln(10)

    # --- Reset text color ---
    pdf.set_text_color(0, 0, 0)
    pdf.set_font("Times", '', 12)

    # --- User Info ---
    pdf.cell(0, 10, f"Name: {user_name}", ln=True)
    pdf.cell(0, 10, f"Analysis Type: {analysis_type}", ln=True)
    pdf.cell(0, 10, f"Generated on: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}", ln=True)
    pdf.ln(5)

    # --- Input Text ---
    pdf.set_font("Times", 'BI', 14)
    pdf.cell(0, 10, "Input Text:", ln=True)
    pdf.set_font("Times", '', 12)
    pdf.multi_cell(0, 8, user_text)
    pdf.ln(5)

    # --- Prediction ---
    pdf.set_font("Times", 'BI', 14)
    pdf.cell(0, 10, "Prediction Result:", ln=True)
    pdf.set_font("Times", '', 12)
    pdf.cell(0, 10, f"Prediction: {prediction}", ln=True)
    pdf.cell(0, 10, f"Confidence: {confidence:.2f}", ln=True)
    pdf.ln(5)

    # --- Chart ---
    chart_path = os.path.join(tempfile.gettempdir(), "proba_chart.png")
    plt.figure(figsize=(5, 3))
    plt.bar(proba_df.iloc[:, 0], proba_df.iloc[:, 1], color='#004aad')
    plt.title("Prediction Probabilities")
    plt.xlabel("Class")
    plt.ylabel("Probability")
    plt.tight_layout()
    plt.savefig(chart_path)
    plt.close()

    pdf.set_font("Times", 'BI', 14)
    pdf.cell(0, 10, "Probability Chart:", ln=True)
    pdf.image(chart_path, w=150)
    pdf.ln(10)

    # --- Footer ---
    pdf.set_font("Times", 'I', 10)
    pdf.cell(0, 10, "Generated by TonoSense | Powered by Streamlit & Python", ln=True, align='C')

    # --- Save ---
    timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
    safe_name = user_name.replace(" ", "_")
    pdf_path = os.path.join(tempfile.gettempdir(), f"{safe_name}_TonoSense_Report_{timestamp}.pdf")
    pdf.output(pdf_path)

    return pdf_path

def submit_feedback(name, email, feedback_text):
    try:
        scope = ["https://spreadsheets.google.com/feeds", "https://www.googleapis.com/auth/drive"]
        creds_dict = json.loads(st.secrets["google"]["credentials"])
        creds = ServiceAccountCredentials.from_json_keyfile_dict(creds_dict, scope)
        client = gspread.authorize(creds)
        sheet = client.open("TonoSense Feedback").sheet1
        sheet.append_row([datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"), name, email, feedback_text])
        return True
    except Exception as e:
        st.error(f"‚ùå Feedback submission failed.\n\nDetails: {e}")
        return False

def transcribe_voice():
    recognizer = sr.Recognizer()
    with sr.Microphone() as source:
        st.info("üéôÔ∏è Listening... Please speak clearly")
        audio = recognizer.listen(source, phrase_time_limit=10)
        try:
            return recognizer.recognize_google(audio)
        except sr.UnknownValueError:
            return None
        except sr.RequestError:
            return None

def load_lottiefile(filepath: str):
    with open(filepath, "r") as f:
        return json.load(f)

# ---------------------------------------
# FINAL MAIN with fade trick
def main():
    st.markdown(f"""
<style>
@import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap');

html, body, [class*="css"] {{
  font-family: 'Poppins', sans-serif;
  background: linear-gradient(180deg, #0a1a2f 0%, #0a1a2f 50%, #0f2235 100%);
  color: #f8f9fa;
}}

.wave-header {{
  position: relative;
  background: radial-gradient(circle at 50% 0%, #498184 0%, #004aad 100%);
  height: 240px;
  text-align: center;
  overflow: hidden;
  border-bottom-left-radius: 50% 10%;
  border-bottom-right-radius: 50% 10%;
  display: flex;
  align-items: center;
  justify-content: center;
}}

.wave-header img.logo {{
  max-width: 380px;
  height: auto;
  z-index: 5;
}}

.wave-header svg.wave {{
  position: absolute;
  bottom: 0;
  left: 0;
  width: 100%;
  height: 100px;
}}

.icon {{
  position: absolute;
  width: 40px;
  height: 40px;
  opacity: 0.15;
  animation: float 12s ease-in-out infinite;
}}

.icon1 {{ top: 30px; left: 30px; animation-delay: 0s; }}
.icon2 {{ top: 50px; right: 50px; animation-delay: 2s; }}
.icon3 {{ top: 50%; left: 50%; transform: translate(-50%, -50%); animation-delay: 4s; }}
.icon4 {{ top: 40px; right: 100px; animation-delay: 6s; }}
.icon5 {{ bottom: 30px; left: 80px; animation-delay: 8s; }}

@keyframes float {{
  0%   {{ transform: translateY(0); }}
  50%  {{ transform: translateY(-20px); }}
  100% {{ transform: translateY(0); }}
}}

/* --- FORM STYLES --- */
input[type="text"], textarea {{
  width: 100%;
  padding: 10px 14px;
  border: 2px solid #004aad;
  border-radius: 8px;
  background: #0f2235;
  color: #ffffff;
  font-size: 15px;
}}

input[type="text"]:focus, textarea:focus {{
  border-color: #5de0e6;
  outline: none;
  background: #0c1c2e;
}}

div.stButton > button {{
  background: #004aad;
  color: #fff;
  border: none;
  border-radius: 25px;
  padding: 0.6em 1.4em;
  font-weight: 600;
  font-size: 15px;
  transition: 0.3s;
}}

div.stButton > button:hover {{
  background: #5de0e6;
  color: #000;
  transform: translateY(-2px);
  box-shadow: 0 6px 20px rgba(0,0,0,0.2);
  cursor: pointer;
}}

/* Smaller logo for mobile */
@media (max-width: 768px) {{
  .wave-header {{ height: 200px; }}
  .wave-header img.logo {{ max-width: 160px; }}
}}

/* Custom spinner style */
div[data-testid="stSpinner"] > div {{
  border: 4px solid #004aad;
  border-top: 4px solid #5de0e6;
  border-radius: 50%;
  width: 50px;
  height: 50px;
  animation: spin 1s linear infinite;
  margin: 30px auto;
}}

@keyframes spin {{
  0% {{ transform: rotate(0deg); }}
  100% {{ transform: rotate(360deg); }}
}}

div[data-testid="stSpinner"] p {{
  text-align: center;
  font-weight: 600;
  color: #5de0e6;
  margin-top: 60px;
}}
</style>

<!-- FULL WAVE HEADER WITH ICONS & WAVES -->
<div class="wave-header">

  <!-- Floating icons -->
  <div class="icon icon1">
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" stroke="#fff" stroke-width="2" viewBox="0 0 24 24">
      <path d="M14.828 14.828a4 4 0 01-5.656 0M9 9h.01M15 9h.01M12 20a8 8 0 100-16 8 8 0 000 16z"/>
    </svg>
  </div>

  <div class="icon icon2">
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" stroke="#fff" stroke-width="2" viewBox="0 0 24 24">
      <path d="M12 2a7 7 0 00-7 7c0 2.5 1.5 4 2.5 5.5L8 17h8l.5-2.5c1-1.5 2.5-3 2.5-5.5a7 7 0 00-7-7z"/><path d="M9 21h6"/>
    </svg>
  </div>

  <div class="icon icon3">
    <svg xmlns="http://www.w3.org/2000/svg" fill="#fff" viewBox="0 0 24 24">
      <path d="M12 2l2.4 7.2H22l-5.6 4 2.4 7.2L12 16l-6.8 4.4 2.4-7.2L2 9.2h7.6z"/>
    </svg>
  </div>

  <div class="icon icon4">
    <svg xmlns="http://www.w3.org/2000/svg" fill="#fff" viewBox="0 0 24 24">
      <path d="M5 12l1-4-4-1 4-1 1-4 1 4 4 1-4 1-1 4zM17 12l1-4-4-1 4-1 1-4 1 4 4 1-4 1-1 4z"/>
    </svg>
  </div>

  <div class="icon icon5">
    <svg xmlns="http://www.w3.org/2000/svg" fill="#fff" viewBox="0 0 24 24">
      <path d="M12 21C12 21 5 14.5 5 9.5C5 6.4 7.4 4 10.5 4C11.7 4 12.9 4.5 13.7 5.3L12 7L10.3 5.3C11.1 4.5 12.3 4 13.5 4C16.6 4 19 6.4 19 9.5C19 14.5 12 21 12 21Z"/>
    </svg>
  </div>

  <!-- Logo centered -->
  <img src="data:image/png;base64,{logo_base64}" alt="Logo" class="logo" />

  <!-- Main wave -->
  <svg class="wave" viewBox="0 0 1440 320" preserveAspectRatio="none">
    <defs>
      <linearGradient id="grad1" x1="0%" y1="0%" x2="0%" y2="100%">
        <stop offset="0%" style="stop-color:#498184;stop-opacity:1" />
        <stop offset="90%" style="stop-color:#0a1a2f;stop-opacity:1" />
      </linearGradient>
    </defs>
    <path fill="url(#grad1)" d="M0,192L80,181.3C160,171,320,149,480,138.7C640,128,800,128,960,138.7C1120,149,1280,171,1360,181.3L1440,192L1440,320L0,320Z"></path>
  </svg>

  <!-- Subtle second wave for depth -->
  <svg class="wave" style="bottom:-20px; opacity:0.4;" viewBox="0 0 1440 320" preserveAspectRatio="none">
    <path fill="#004aad" d="M0,224L80,202.7C160,181,320,139,480,117.3C640,96,800,96,960,117.3C1120,139,1280,181,1360,202.7L1440,224L1440,320L0,320Z"></path>
  </svg>
</div>
""", unsafe_allow_html=True)



    if "user_name" not in st.session_state:
        user_name = st.text_input("üë§ Enter your name", placeholder="e.g., Minark")
        if user_name.strip():
            st.session_state.user_name = user_name
            st.session_state.show_splash = True
            st.rerun()
        else:
            st.warning("‚ö†Ô∏è Please enter your name to proceed.")
            return

    elif st.session_state.get("show_splash", False):
        lottie_splash = load_lottiefile("Main Scene.json")
        st_lottie(lottie_splash, speed=1, loop=False, height=500)
        st.info("Loading your personalized workspace... ü§ñ")
        time.sleep(2.5)
        st.session_state.show_splash = False
        st.rerun()

    else:
        # Fade-in for main page
        with st.container():
            st.markdown('<div class="fade-in">', unsafe_allow_html=True)
            show_main_page()
            st.markdown('</div>', unsafe_allow_html=True)


def show_main_page():
    user_name = st.session_state.user_name
    st.subheader(f"üéâ Welcome, {user_name}! üëã Ready to analyze text üß†")
    st.info("üí° Tip: Try tweet-length text for better detection")

    st.markdown("<span title='Choose what type of analysis you want to perform'>üìä <b>Choose Analysis Type</b></span>", unsafe_allow_html=True)
    analysis_mode = st.selectbox(" ", ["Sentiment Analysis", "Emotion Detection"])

    st.markdown("### ‚úçÔ∏è Input your text below")
    input_mode = st.radio("Choose input method:", ["Type", "Voice"])

    raw_text = ""
    analyze_now = False

    if input_mode == "Type":
        raw_text = st.text_area("üìù Enter your text", height=150)
        analyze_now = st.button('üîç Analyze')
    else:
        if st.button("üéôÔ∏è Speak Now"):
            transcribed = transcribe_voice()
            if transcribed:
                raw_text = transcribed
                st.success(f"üìù Transcribed Text:\n\n> {transcribed}")
                analyze_now = True
            else:
                st.error("‚ùå Could not transcribe your voice. Please try again.")

    if analyze_now and raw_text.strip():
        with st.spinner("Analyzing your text... üß†"):
            col1, col2 = st.columns(2)

            if analysis_mode == "Emotion Detection":
                prediction = predict_emotions(raw_text)
                probability = get_prediction_proba(raw_text)
                emoji_icon = emotions_emoji_dict.get(prediction, "")
                confidence = np.max(probability)

                with col1:
                    st.success("Original Text")
                    st.write(raw_text)
                    st.success("Predicted Emotion")
                    st.write(f"{prediction} {emoji_icon} | Confidence: {confidence:.2f}")

                with col2:
                    st.success("Prediction Probabilities")
                    proba_df = pd.DataFrame(probability, columns=pipe_lr.classes_)
                    proba_df_clean = proba_df.T.reset_index()
                    proba_df_clean.columns = ["emotion", "probability"]
                    fig = px.bar(
                        proba_df_clean,
                        x="emotion",
                        y="probability",
                        color="emotion",
                        text="probability",
                        title="Prediction Probabilities",
                    )

                    fig.update_traces(
                        texttemplate='%{text:.2f}',
                        textposition='outside',
                        marker_line_width=1.5,
                        opacity=0.8
                    )

                    fig.update_layout(
                        yaxis=dict(range=[0, 1]),
                        transition={'duration': 800},
                        plot_bgcolor='rgba(0,0,0,0)',
                        paper_bgcolor='rgba(0,0,0,0)',
                        font=dict(color='#f8f9fa')
                    )

                    st.plotly_chart(fig, use_container_width=True)

                pdf_path = export_to_pdf(user_name, raw_text, prediction, confidence, analysis_mode, proba_df_clean)

            else:
                prediction = predict_sentiment(raw_text)
                probability = get_sentiment_proba(raw_text)
                emoji_icon = sentiment_emoji_dict.get(prediction.lower(), "")
                confidence = np.max(probability)

                with col1:
                    st.success("Original Text")
                    st.write(raw_text)
                    st.success("Predicted Sentiment")
                    st.write(f"{prediction} {emoji_icon} | Confidence: {confidence:.2f}")

                    if prediction.lower() == "positive":
                        st.balloons()
                    elif prediction.lower() == "negative":
                        st.snow()

                with col2:
                    st.success("Prediction Probabilities")
                    proba_df = pd.DataFrame(probability, columns=sentiment_pipe.classes_)
                    proba_df_clean = proba_df.T.reset_index()
                    proba_df_clean.columns = ["sentiment", "probability"]
                    fig = px.bar(
                        proba_df_clean,
                        x="sentiment",
                        y="probability",
                        color="sentiment",
                        text="probability",
                        title="Prediction Probabilities",
                    )

                    fig.update_traces(
                        texttemplate='%{text:.2f}',
                        textposition='outside',
                        marker_line_width=1.5,
                        opacity=0.8
                    )

                    fig.update_layout(
                        yaxis=dict(range=[0, 1]),
                        transition={'duration': 800},
                        plot_bgcolor='rgba(0,0,0,0)',
                        paper_bgcolor='rgba(0,0,0,0)',
                        font=dict(color='#f8f9fa')
                    )

                    st.plotly_chart(fig, use_container_width=True)

                pdf_path = export_to_pdf(user_name, raw_text, prediction, confidence, analysis_mode, proba_df_clean)

            with open(pdf_path, "rb") as f:
                file_name = os.path.basename(pdf_path)
                st.download_button(label="üìÑ üì• Download PDF Report", data=f, file_name=file_name, mime="application/pdf")

    st.markdown("---")
    with st.expander("üí¨ Leave Feedback"):
        name = st.text_input("Your Name")
        email = st.text_input("Email")
        feedback_text = st.text_area("Feedback")
        if st.button("Submit Feedback"):
            if submit_feedback(name, email, feedback_text):
                st.success("‚úÖ Feedback submitted!")

    st.markdown("<div style='text-align: center; color: gray;'>Built with ‚ù§Ô∏è using Streamlit | Created by Minark</div>", unsafe_allow_html=True)


if __name__ == '__main__':
    main()
